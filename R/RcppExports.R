# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Function that computes the log-likelihood of the observed data
NULL

#' Function that computes the log-likelihood of the observed data
#'  
#' @param K an integer indicating the number of markers
#' @param nD an integer indicating the number of latent processes
#' @param mapping indicates which outcome measured which latent process, it is a mapping table between
#' outcomes and latents processes
#' @param paraOpt initial values for model parameters
#' @param paraFixe values associated to the index of parameters to be constrained
#' @param posfix position of parameters to be constrained
#' @param m_is vector of numbers of visit occasions for individuals
#' @param Mod_MatrixY model.matrix from markers transformation submodels
#' @param Mod_MatrixYprim model.matrix from the derivates of markers transformation submodels
#' @param df vector of numbers of parameters for each transformation model
#' @param nb_paraD number of paramerters of the variance-covariance matrix of random effects
#' @param x0 model.matrix for baseline's fixed submodel
#' @param x model.matrix for change's fixed submodel
#' @param z0 model.matrix for baseline's random effects submodel
#' @param z model.matrix for change's random effects submodel
#' @param q0 a vector of number of random effects on each initial latent process level
#' @param cholesky logical indicating if the variance covariance matrix is parameterized using the cholesky (TRUE, by default) or the correlation (FALSE)
#' @param q a vector of number of random effects on each change latent process over time
#' @param if_link indicates if non linear link is used to transform an outcome
#' @param tau a vector of integers indicating times (including maximum time)
#' @param tau_is a vector of integers indicating times for individuals
#' @param modA_mat model.matrix for elements of the transistion matrix
#' @param DeltaT double that indicates the discretization step  
#' @param data_surv matrix of Tentry, Event, StatusEvent and covariates for survival models
#' @param data_surv_intY matrix of covariates in interaction with Y in survival models
#' @param nYsurv number of covariates in interaction with Y in survival models for all nEvents
#' @param basehaz baseline hasard function type
#' @param knots_surv knots for splines modelling the baseline hazard function
#' @param np_surv number of parameters in the survival sub-models !! change if nE>1 !!
#' @param survival boolean indicating if survival analysis
#' @param assoc type of association between outcomes and times-to-events
#' @param truncation boolean indicating if left trucation 
#' @param nE number of events
#' @param Xsurv1 design matrix for first event
#' @param Xsurv2 design matrix for second event
#' @param zitr min and max of ordinal outcomes
#' @param ide vector of observed values for ordinal outcomes
#' @param modA_mat_predGK_t design matrix for computing predictions of Y on [0;ti] in Gauss Konrod for all subject
#' @param modA_mat_predGK_t0 design matrix for computing predictions of Y on [0;t0i] in Gauss Konrod for all subject
#' @param pt_GK_t Gauss-Konrod nodes for integration on [0;ti] for all subject
#' @param pt_GK_t0 Gauss-Konrod nodes for integration on [0;t0i] for all subject
#' @return double 
#' @export
#' 
Loglik <- function(K, nD, mapping, paraOpt, paraFixe, posfix, paras_k, sequence, type_int, ind_seq_i, MCnr, nmes, m_is, Mod_MatrixY, Mod_MatrixYprim, df, x, z, q, nb_paraD, x0, z0, q0, cholesky, data_surv, data_surv_intY, nYsurv, basehaz, knots_surv, np_surv, survival, assoc, truncation, nE, Xsurv1, Xsurv2, if_link, zitr, ide, tau, tau_is, modA_mat, DeltaT, ii) {
    .Call(`_CInLPN2_Loglik`, K, nD, mapping, paraOpt, paraFixe, posfix, paras_k, sequence, type_int, ind_seq_i, MCnr, nmes, m_is, Mod_MatrixY, Mod_MatrixYprim, df, x, z, q, nb_paraD, x0, z0, q0, cholesky, data_surv, data_surv_intY, nYsurv, basehaz, knots_surv, np_surv, survival, assoc, truncation, nE, Xsurv1, Xsurv2, if_link, zitr, ide, tau, tau_is, modA_mat, DeltaT, ii)
}

Loglik2 <- function(K, nD, mapping, paraOpt, paraFixe, posfix, paras_k, sequence, type_int, ind_seq_i, MCnr, nmes, m_is, Mod_MatrixY, Mod_MatrixYprim, df, x, z, q, nb_paraD, x0, z0, q0, cholesky, data_surv, data_surv_intY, nYsurv, basehaz, knots_surv, np_surv, survival, assoc, truncation, nE, Xsurv1, Xsurv2, if_link, zitr, ide, tau, tau_is, modA_mat, DeltaT, ii, ui) {
    .Call(`_CInLPN2_Loglik2`, K, nD, mapping, paraOpt, paraFixe, posfix, paras_k, sequence, type_int, ind_seq_i, MCnr, nmes, m_is, Mod_MatrixY, Mod_MatrixYprim, df, x, z, q, nb_paraD, x0, z0, q0, cholesky, data_surv, data_surv_intY, nYsurv, basehaz, knots_surv, np_surv, survival, assoc, truncation, nE, Xsurv1, Xsurv2, if_link, zitr, ide, tau, tau_is, modA_mat, DeltaT, ii, ui)
}

#' Function that computes the predictions (marginal and subject-specific) for individuals
NULL

#' Function that computes the predictions (marginal and subject-specific) for individuals
#'  
#' @param K an integer indicating the number of markers
#' @param nD an integer indicating the number of latent processes
#' @param mapping indicates which outcome measured which latent process, it is a mapping table between
#' outcomes and latents processes
#' @param paras values of model parameters
#' @param m_is vector of numbers of visit occasions for individuals
#' @param Mod_MatrixY model.matrix from markers transformation submodels
#' @param df vector of numbers of parameters for each transformation model
#' @param nb_paraD number of paramerters of the variance-covariance matrix of random effects
#' @param x0 model.matrix for baseline's fixed submodel
#' @param x model.matrix for change's fixed submodel
#' @param z0 model.matrix for baseline's random effects submodel
#' @param z model.matrix for change's random effects submodel
#' @param q0 a vector of number of random effects on each initial latent process level
#' @param q a vector of number of random effects on each change latent process over time
#' @param if_link indicates if non linear link is used to transform an outcome
#' @param tau a vector of integers indicating times (including maximum time)
#' @param tau_is a vector of integers indicating times for individuals
#' @param modA_mat model.matrix for elements of the transistion matrix
#' @param DeltaT double that indicates the discretization step  
#' @param MCnr an integer that indicates the number of sample for MC method  
#' @param minY a vector of minima of outcomes
#' @param maxY a vector of maxima of outcomes
#' @param knots indicates position of knots used to transform outcomes
#' @param degree indicates degree of the basis of splines
#' @param epsPred convergence criteria for prediction using MC method//' 
#' @return a matrix
#' @export
#' 
pred <- function(K, nD, mapping, paras, m_is, Mod_MatrixY, df, x, z, q, cholesky, nb_paraD, x0, z0, q0, if_link, tau, tau_is, modA_mat, DeltaT, MCnr, minY, maxY, knots, degree, epsPred, ui_hat, nE = 0L) {
    .Call(`_CInLPN2_pred`, K, nD, mapping, paras, m_is, Mod_MatrixY, df, x, z, q, cholesky, nb_paraD, x0, z0, q0, if_link, tau, tau_is, modA_mat, DeltaT, MCnr, minY, maxY, knots, degree, epsPred, ui_hat, nE)
}

pred0 <- function(K, nD, mapping, paras, m_is, Mod_MatrixY, df, x, z, q, nb_paraD, x0, z0, q0, if_link, tau, tau_is, modA_mat, DeltaT, MCnr, minY, maxY, knots, degree, epsPred) {
    .Call(`_CInLPN2_pred0`, K, nD, mapping, paras, m_is, Mod_MatrixY, df, x, z, q, nb_paraD, x0, z0, q0, if_link, tau, tau_is, modA_mat, DeltaT, MCnr, minY, maxY, knots, degree, epsPred)
}

#'  Function that constructs the matrix matYtild_ui (Lambda_i|ui), the expectation of the processes at time t_j given ui
NULL

#' gammaX vector of linear predictors for 1 and 2 transitions (including association on random effects if assoc <=2)
#' surv Computation of survival funtion (1) or risk function (0)
#' trans index for computation of survival function on all transitions (-1), on first transition(0), or second transition (1) for nE=2
#' when 
NULL

#' ptGK_delta vector of projections of GK nodes onto grid of delta
#' ptGK vector of individual GK nodes
#' alpha vector of association parameters
#' delta_i event status 
#' survfunc indicator if output is survival function or hazard risk
#' trans index for computation of survival/risk function on all transitions (-1), on first transition(0), or second transition (1)
NULL

#' ui_r vector of individual random effects
#' t_i individual time-to-event
#' delta_i individual status of event
#' xti1 vector of individual covariates for first event
#' xti2 vector of individual covariates for competing event
#' param_surv regression parameters
#' param_basehaz parameters for baseline hazard function
#' basehaz type of baseline hazard function
#' knots_surv vector of knots if basehaz == Splines
#' assoc function of the random effects that captures association 
#' //'    (0: random intercept, 1: random slope, 2: random intercept and slope, 3: current value, 4: current slope, 5: current value and slope)
#' truncation boolean, indicating if left truncation or not
#' 
NULL

#' Function that vectorises a matrix by rows
#' 
#' @param M a matrix
#' @export
vectorise <- function(M) {
    .Call(`_CInLPN2_vectorise`, M)
}

#' Function that creates a K-block diagonal matrix with non diagonal element fixed to 0
#' 
#' @param Kvector a vector of length K
#' 
#' @return a diagonal matrix
#' @export
#' 
KmatDiag <- function(Kvector) {
    .Call(`_CInLPN2_KmatDiag`, Kvector)
}

#'  Function that computes a symetric D matric from it Cholesky L
#'  
#' @param q an integer
#' @param qvector a vector of length q
#' 
#' @return a symetric positive define matrix
#' @export
#' 
DparChol <- function(q, qvector) {
    .Call(`_CInLPN2_DparChol`, q, qvector)
}

#'  Function that computes all coefficients of the transition matrix at time t
#'  
#' @param K an integer representing the size of K*K matrix
#' @param t an integer indicating the time at which coefficients are computed 
#' @param modA_mat model.matrix for elements of the transistion matrix  
#' @param vec_alpha_ij a vector of overall parameters associated to the
#' model.matrix for elements of the transistion matrix 
#' 
#' @return a vector of elements of the transition matrix
#' @export
#' 
vecaijt <- function(K, t, vec_alpha_ij, modA_mat) {
    .Call(`_CInLPN2_vecaijt`, K, t, vec_alpha_ij, modA_mat)
}

#'  Function that  constructs the transition matrix at time t
#'  
#' @param K an integer representing the size of K*K matrix
#' @param t an integer indicating the time at which coefficients are computed 
#' @param DeltaT double that indicates the discretization step
#' @param modA_mat model.matrix for elements of the transistion matrix  
#' @param vec_alpha_ij a vector of overall parameters associated to the
#' model.matrix for elements of the transistion matrix 
#' 
#' @return Id + DeltaT*A where A is the transition matrix
#' @export
#' 
ConstrA <- function(K, t, DeltaT, vec_alpha_ij, modA_mat) {
    .Call(`_CInLPN2_ConstrA`, K, t, DeltaT, vec_alpha_ij, modA_mat)
}

#'  Function that  creates a matrix K,K*(max(tau_i)-1) containing  sub-matrices {(A_t)}_{t=0,tau_i-1}
#'  
#' @param K an integer representing the size of K*K matrix
#' @param tau_i vector of integers indicating times at which coefficients are computed 
#' @param DeltaT double that indicates the discretization step
#' @param modA_mat model.matrix for elements of the transition matrix  
#' @param vec_alpha_ij a vector of overall parameters associated to the
#' model.matrix for elements of the transistion matrix 
#' 
#' @return a matrix containing matrix of form Id + DeltaT*A
#' @export
#' 
GmatA0totaui <- function(K, vec_alpha_ij, tau_i, DeltaT, modA_mat) {
    .Call(`_CInLPN2_GmatA0totaui`, K, vec_alpha_ij, tau_i, DeltaT, modA_mat)
}

#'  Function that  computes the product of A(t) for t1 to t2
#'  
#' @param K an integer representing the size of K*K matrix
#' @param t1 indicates the started discretized time
#' @param t2 indicates the ended discretized time
#' @param DeltaT double that indicates the discretization step
#' @param modA_mat model.matrix for elements of the transistion matrix  
#' @param vec_alpha_ij a vector of overall parameters associated to the
#' model.matrix for elements of the transistion matrix 
#' 
#' @return a matrix
#' @export
#' 
ProdA <- function(K, t2, t1, DeltaT, vec_alpha_ij, modA_mat) {
    .Call(`_CInLPN2_ProdA`, K, t2, t1, DeltaT, vec_alpha_ij, modA_mat)
}

#'  Function that  creates a big matrix containing  Prod(A_t)t=t_ini,tau.
#'  
#' @param K an integer representing the size of K*K matrix
#' @param t_ini indicates the started discretized time
#' @param tau vector of integers indicating times 
#' @param DeltaT double that indicates the discretization step
#' @param modA_mat model.matrix for elements of the transistion matrix  
#' @param vec_alpha_ij a vector of overall parameters associated to the
#' model.matrix for elements of the transistion matrix 
#' 
#' @return a matrix
#' @export
#' 
GmatprodAstotau <- function(K, vec_alpha_ij, tau, t_ini, DeltaT, modA_mat) {
    .Call(`_CInLPN2_GmatprodAstotau`, K, vec_alpha_ij, tau, t_ini, DeltaT, modA_mat)
}

#'  Function that  creates a big matrix ts_G_mat_prod_A_0_to_tau containing  Prod(A_t)t=0,tau.
#'  
#' @param K an integer representing the size of K*K matrix
#' @param tau vector of integers indicating times 
#' @param DeltaT double that indicates the discretization step
#' @param modA_mat model.matrix for elements of the transistion matrix  
#' @param vec_alpha_ij a vector of overall parameters associated to the
#' model.matrix for elements of the transistion matrix 
#' 
#' @return a matrix
#' @export
#' 
tsGmatprodA0totau <- function(K, vec_alpha_ij, tau, DeltaT, modA_mat) {
    .Call(`_CInLPN2_tsGmatprodA0totau`, K, vec_alpha_ij, tau, DeltaT, modA_mat)
}

#' After vectorising the vzector Yi, this function returns
#' a vector indicating missing values : 1 = observed value, 0 = missing value
#' 
#' @param Yi a matrix with possibly NAs
#' 
#' @return a vector of elements 0,1
#' @export
#' 
compoYiNA <- function(Yi) {
    .Call(`_CInLPN2_compoYiNA`, Yi)
}

#' Function that returns Yi (a vector) without NAs values
#' 
#' @param Yi a vector with possibly NAs
#' 
#' @return a vector 
#' @export
#' 
YiwoNA <- function(Yi) {
    .Call(`_CInLPN2_YiwoNA`, Yi)
}

#'  Function that constructs the matrix nu_t_j, the expectation of the processes at time t_j
#'  
#' @param nD an integer indicating the number of processes
#' @param tau_i vector of integers indicating times 
#' @param DeltaT double that indicates the discretization step
#' @param x0i model.matrix for baseline's submodel
#' @param xi model.matrix for change's submodel
#' @param alpha_mu0 a vector of parameters associated to the model.matrix for the baseline's submodel
#' @param alpha_mu a vector of parameters associated to the model.matrix for the change's submodel
#' @param G_mat_A_0_to_tau_i matrix containing  Prod(A_t)t=0,tau_i where A_t is the transition
#' matrix containing at time t
#' 
#' @return a matrix
#' @export
#' 
matNui <- function(nD, tau_i, DeltaT, x0i, alpha_mu0, xi, alpha_mu, G_mat_A_0_to_tau_i) {
    .Call(`_CInLPN2_matNui`, nD, tau_i, DeltaT, x0i, alpha_mu0, xi, alpha_mu, G_mat_A_0_to_tau_i)
}

matYtild_ui <- function(nD, tau_i, DeltaT, x0i, alpha_mu0, xi, alpha_mu, G_mat_A_0_to_tau_i, zi, ui, vi) {
    .Call(`_CInLPN2_matYtild_ui`, nD, tau_i, DeltaT, x0i, alpha_mu0, xi, alpha_mu, G_mat_A_0_to_tau_i, zi, ui, vi)
}

#' Function that replaces NAs by 0.0 just for computatinal need
#' 
#' @param Yi a matrix with possibly NAs
#' 
#' @return a matrix 
#' @export
#' 
f_Yi_r_NA_by0 <- function(Yi) {
    .Call(`_CInLPN2_f_Yi_r_NA_by0`, Yi)
}

#' Function that computes the difference (mat_Yi - mat_Nu_i), deletes missing values (NAs) and 
#' returns a vector. mat_Yi is the outcome and mat_Nu_i is the expectation
#'  
#' @param nD an integer indicating the number of processes
#' @param matrixP a matrix that matches markers to latent processes
#' @param tau a vector of integers indicating times 
#' @param tau_i a vector of integers indicating times for individual i
#' @param DeltaT double that indicates the discretization step
#' @param Yi a matrix of the outcomes
#' @param x0i model.matrix for baseline's submodel
#' @param xi model.matrix for change's submodel
#' @param alpha_mu0 a vector of parameters associated to the model.matrix for the baseline's submodel
#' @param alpha_mu a vector of parameters associated to the model.matrix for the change's submodel
#' @param G_mat_A_0_to_tau_i matrix containing  Prod(A_t)t=0,tau_i where A_t is the transition
#' matric containing at time t
#' 
#' @return a vector
#' @export
#' 
YiNui <- function(nD, matrixP, tau, tau_i, DeltaT, Yi, x0i, alpha_mu0, xi, alpha_mu, G_mat_A_0_to_tau_i) {
    .Call(`_CInLPN2_YiNui`, nD, matrixP, tau, tau_i, DeltaT, Yi, x0i, alpha_mu0, xi, alpha_mu, G_mat_A_0_to_tau_i)
}

#' Function that computes the difference (mat_Yi - mat_Nu_i), delates missing values (NAs) and 
#' returns a vector. mat_Yi is the outcomes and mat_Nu_i is the expectation
#'  
#' @param Lambdai a matrix of dimension nT x nD containing the sampled lambda_i
#' @param nD an integer indicating the number of processes
#' @param matrixP a matrix that matches markers to latent processes
#' @param tau a vector of integers indicating times 
#' @param tau_i a vector of integers indicating times for individual i
#' @param DeltaT double that indicates the discretization step
#' @param Yi a matrix of the outcomes
#' @param x0i model.matrix for baseline's submodel
#' @param xi model.matrix for change's submodel
#' @param alpha_mu0 a vector of parameters associated to the model.matrix for the baseline's submodel
#' @param alpha_mu a vector of parameters associated to the model.matrix for the change's submodel
#' @param G_mat_A_0_to_tau_i matrix containing  Prod(A_t)t=0,tau_i where A_t is the transition
#' matric containing at time t
#'  @param paraEtha2 transformation parameters
#'  @param if_link: link function indicator, 0 if linear, 1 if splines, 2 if thresholds
#'  @param zitr: minY and maxY of observed ordinal Y
#'  @param ide indicator if the values between zitr(0) and zitr(1) are observed in Y 
#'  @param paras_k: number of parameters for link function for each marker k
#'  @param K2_lambda_t: vector indicating to which latent process corresponds each value of Lambdai
#'  @param K2_lambda: vector indicating to which latent process corresponds each marker
#' 
#' @return a double
#' @export
#' 
f_marker <- function(Lambdai, nD, matrixP, tau, tau_i, DeltaT, Ytildi, YtildPrimi, x0i, alpha_mu0, xi, paraSig, alpha_mu, G_mat_A_0_to_tau_i, paraEtha2, if_link, zitr, ide, paras_k, K2_lambda_t, K2_lambda) {
    .Call(`_CInLPN2_f_marker`, Lambdai, nD, matrixP, tau, tau_i, DeltaT, Ytildi, YtildPrimi, x0i, alpha_mu0, xi, paraSig, alpha_mu, G_mat_A_0_to_tau_i, paraEtha2, if_link, zitr, ide, paras_k, K2_lambda_t, K2_lambda)
}

#'  Function that constructs the matrix lambda_t_j, the value of the processes at time t_j, given the random effects
#'  
#' @param nD an integer indicating the number of processes
#' @param tau_i vector of integers indicating times 
#' @param DeltaT double that indicates the discretization step
#' @param x0i model.matrix for baseline's submodel
#' @param xi model.matrix for change's submodel
#' @param alpha_mu0 a vector of parameters associated to the model.matrix for the baseline's submodel (beta)
#' @param alpha_mu a vector of parameters associated to the model.matrix for the change's submodel (gamma)
#' @param G_mat_A_0_to_tau_i matrix containing  Prod(A_t)t=0,tau_i where A_t is the transition
#' matric containing at time t
#' @param ui random effects (baseline and slope) dimension: nD*(1+nq_v) x 1 [ui1, ..., uinD, vi1, ..., vinD]
#' @param zi model.matrix for random change's submodel
#' @param ordered indicator if tau_i is ordered or not (usually ordered, except for GK nodes)
#' 
#' @return a vector
#' @export
#' 
matNui_ui <- function(nD, tau_i, DeltaT, x0i, alpha_mu0, xi, alpha_mu, G_mat_A_0_to_tau_i, randomeffects, zi, ordered) {
    .Call(`_CInLPN2_matNui_ui`, nD, tau_i, DeltaT, x0i, alpha_mu0, xi, alpha_mu, G_mat_A_0_to_tau_i, randomeffects, zi, ordered)
}

#' Function that transforms a vector to a matrix
#' 
#' @param y a vector 
#' @param K an integer indicating the number of columns of the returned matrix
#' @param m_i an integer indicating the number of rows of the returned matrix
#' 
#' @return a matrix 
#' @export
#' 
VecToMat <- function(y, K, m_i) {
    .Call(`_CInLPN2_VecToMat`, y, K, m_i)
}

